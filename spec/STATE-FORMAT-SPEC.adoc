= STATE Format Specification
:doctype: book
:toc: left
:toclevels: 4
:sectnums:
:source-highlighter: highlight.js
:icons: font

[.text-center]
*Internet-Draft Style Specification* +
*Version 1.0.0-draft.1* +
*December 2025*

== Abstract

This document specifies the STATE (Stateful Context Tracking Engine) file
format, a human-readable checkpoint format for persisting AI conversation
context across sessions. STATE files use S-expression syntax (Scheme/Lisp)
to encode project state, dependencies, progress tracking, and session
metadata in a format that is both machine-parseable and human-editable.

== Status of This Document

This is a draft specification intended for community review and eventual
submission to appropriate standards bodies. The target standards track is:

1. **Primary**: IETF Informational RFC (format specification)
2. **Secondary**: IANA Media Type Registration (`application/x-state+scheme`)
3. **Future**: W3C JSON-LD Context (for semantic web interoperability)

== Copyright Notice

SPDX-License-Identifier: MIT AND LicenseRef-Palimpsest-0.8

Copyright (c) 2025 Jonathan D.A. Jewell. This document may be distributed
under the terms of the MIT License.

== Table of Contents

toc::[]

== Introduction

=== Problem Statement

Large Language Model (LLM) conversations are inherently stateless. Each new
conversation session starts with zero context about:

* Ongoing projects and their current status
* Decisions already made and their rationale
* Dependencies between work items
* Blockers and next actions
* Historical progress data

This forces users to repeatedly re-explain context, leading to:

* Lost productivity from context reconstruction
* Inconsistent decision-making across sessions
* Inability to track long-term project evolution
* No persistent record of AI-assisted work

=== Solution Overview

The STATE format provides a standardized, portable checkpoint file that
captures conversation context in a declarative format. Key properties:

[cols="1,3"]
|===
|Property |Description

|Human-readable
|S-expression syntax is minimal and self-documenting

|Machine-parseable
|Standard Scheme/Lisp parsing; JSON/YAML bindings available

|Portable
|Text-based; works across all platforms and AI systems

|Versionable
|Git-friendly; changes are visible in diffs

|Queryable
|Supports relational queries via minikanren-style logic programming
|===

=== Conventions

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119.

=== Terminology

STATE file::
  A file conforming to this specification, typically named `STATE.scm`

Section::
  A top-level named block within the STATE structure (e.g., `metadata`, `projects`)

Entry::
  An individual record within a section (e.g., a single project definition)

Pair::
  A key-value association in dotted-pair notation: `(key . value)`

S-expression::
  Symbolic expression; the fundamental syntax unit in Lisp/Scheme

== Format Overview

=== File Structure

A STATE file MUST be a valid Scheme source file containing a single
top-level definition:

[source,scheme]
----
(define state
  '((metadata ...)
    (user ...)
    (session ...)
    (focus ...)
    (projects ...)
    ...))
----

The quoted list contains sections in the order specified by this document.

=== Character Encoding

STATE files MUST be encoded in UTF-8. The byte order mark (BOM) SHOULD NOT
be present but MAY be ignored if encountered.

=== Line Endings

STATE files SHOULD use Unix line endings (LF, `\n`). Parsers MUST accept
both Unix (LF) and Windows (CRLF) line endings.

=== Comments

Scheme-style comments are permitted:

[source,scheme]
----
; Single-line comment (semicolon to end of line)
#| Multi-line block comment |#
----

Comments SHOULD be used to provide human-readable context but MUST NOT
contain information required for parsing.

== Section Specifications

=== metadata (REQUIRED)

The `metadata` section contains format versioning and temporal information.

[source,scheme]
----
(metadata
  (format-version . "2.0")
  (schema-version . "2025-12-08")
  (created-at . "2025-12-01T10:00:00Z")
  (last-updated . "2025-12-08T12:00:00Z")
  (generator . "Claude/STATE-system"))
----

==== Fields

[cols="2,1,1,4"]
|===
|Field |Type |Required |Description

|`format-version`
|SemVer
|REQUIRED
|Major.minor version of this specification

|`schema-version`
|Date
|REQUIRED
|ISO 8601 date of schema revision

|`created-at`
|DateTime
|REQUIRED
|ISO 8601 timestamp of file creation

|`last-updated`
|DateTime
|REQUIRED
|ISO 8601 timestamp of last modification

|`generator`
|String
|RECOMMENDED
|Identifier of the system that generated the file
|===

==== Version Compatibility

Format version follows Semantic Versioning 2.0.0:

* **Major** version changes indicate breaking changes
* **Minor** version changes add features in a backward-compatible manner
* **Patch** version changes are for backward-compatible bug fixes

Parsers MUST reject files with a higher major version than supported.
Parsers SHOULD accept files with a higher minor version, ignoring unknown
fields.

=== user (REQUIRED)

The `user` section identifies the human operator and their preferences.

[source,scheme]
----
(user
  (name . "Jonathan D.A. Jewell")
  (roles . ("Project Lead" "Architect"))
  (preferences
    (languages-preferred . ("Guile Scheme" "Rust" "Elixir"))
    (languages-avoid . ())
    (tools-preferred . ("Guix" "Nix" "Podman"))
    (values . ("FOSS" "reproducibility" "formal-verification"))))
----

==== Fields

[cols="2,1,1,4"]
|===
|Field |Type |Required |Description

|`name`
|String
|REQUIRED
|Display name of the user

|`roles`
|String[]
|RECOMMENDED
|User's roles in the project context

|`preferences`
|Object
|OPTIONAL
|Nested preference settings
|===

==== Preferences Subfields

[cols="2,1,4"]
|===
|Field |Type |Description

|`languages-preferred`
|String[]
|Programming languages the user prefers

|`languages-avoid`
|String[]
|Languages to avoid suggesting

|`tools-preferred`
|String[]
|Preferred development tools

|`values`
|String[]
|Guiding principles and values
|===

=== session (REQUIRED)

The `session` section tracks the current conversation context.

[source,scheme]
----
(session
  (conversation-id . "2025-12-08-STATE-STATUS")
  (started-at . "2025-12-08T12:00:00Z")
  (messages-used . 42)
  (messages-remaining . 58)
  (token-limit-reached . #f))
----

==== Fields

[cols="2,1,1,4"]
|===
|Field |Type |Required |Description

|`conversation-id`
|String
|REQUIRED
|Unique identifier for the conversation

|`started-at`
|DateTime
|REQUIRED
|When this session began

|`messages-used`
|Integer
|RECOMMENDED
|Count of messages exchanged

|`messages-remaining`
|Integer
|OPTIONAL
|Estimated remaining capacity

|`token-limit-reached`
|Boolean
|OPTIONAL
|Whether context limit was hit
|===

=== focus (REQUIRED)

The `focus` section indicates the user's current work context.

[source,scheme]
----
(focus
  (current-project . "STATE.scm")
  (current-phase . "Phase 3 - Automation")
  (deadline . #f)
  (blocking-projects . ()))
----

==== Fields

[cols="2,1,1,4"]
|===
|Field |Type |Required |Description

|`current-project`
|String
|REQUIRED
|Name of the active project

|`current-phase`
|String
|RECOMMENDED
|Current development phase

|`deadline`
|DateTime\|#f
|OPTIONAL
|Hard deadline if any; `#f` if none

|`blocking-projects`
|String[]
|OPTIONAL
|Projects blocking current focus
|===

=== projects (REQUIRED)

The `projects` section contains the complete project catalog.

[source,scheme]
----
(projects
  ((name . "My Project")
   (status . "in-progress")
   (completion . 65)
   (category . "infrastructure")
   (phase . "development")
   (dependencies . ("Base Library"))
   (blockers . ("Waiting for API approval"))
   (next . ("Implement feature X" "Write tests"))
   (chat-reference . "2025-12-08-discussion")
   (notes . "On track for milestone")))
----

==== Project Entry Fields

[cols="2,1,1,4"]
|===
|Field |Type |Required |Description

|`name`
|String
|REQUIRED
|Unique project identifier

|`status`
|Enum
|REQUIRED
|Current project status

|`completion`
|Integer
|REQUIRED
|Percentage complete (0-100)

|`category`
|String
|RECOMMENDED
|Project category/domain

|`phase`
|String
|OPTIONAL
|Current phase identifier

|`dependencies`
|String[]
|REQUIRED
|Projects this depends on

|`blockers`
|String[]
|REQUIRED
|Current blocking issues

|`next`
|String[]
|REQUIRED
|Prioritized next actions

|`chat-reference`
|String\|#f
|OPTIONAL
|Related conversation ID

|`notes`
|String
|OPTIONAL
|Free-form notes
|===

==== Status Enumeration

[cols="1,3"]
|===
|Value |Description

|`in-progress`
|Actively being worked on

|`blocked`
|Cannot proceed due to external factors

|`paused`
|Temporarily suspended by user choice

|`complete`
|Successfully finished

|`abandoned`
|Permanently discontinued
|===

=== critical-next (RECOMMENDED)

Prioritized list of immediate actions.

[source,scheme]
----
(critical-next
  ("Complete API specification"
   "Review pull request #42"
   "Schedule architecture review"))
----

This section contains a simple list of strings, ordered by priority
(highest first).

=== issues (OPTIONAL)

Known issues, bugs, and limitations.

[source,scheme]
----
(issues
  ((id . "ISSUE-001")
   (severity . "medium")
   (title . "Performance regression")
   (description . "Slow queries on large datasets")
   (workaround . "Use pagination")
   (status . "documented")))
----

==== Issue Entry Fields

[cols="2,1,1,4"]
|===
|Field |Type |Required |Description

|`id`
|String
|REQUIRED
|Unique issue identifier

|`severity`
|Enum
|REQUIRED
|Impact level

|`title`
|String
|REQUIRED
|Brief description

|`description`
|String
|REQUIRED
|Detailed explanation

|`workaround`
|String
|OPTIONAL
|Temporary solution

|`status`
|String
|REQUIRED
|Current issue status
|===

==== Severity Enumeration

`critical` > `high` > `medium` > `low` > `info`

=== questions (OPTIONAL)

Pending decisions requiring user input.

[source,scheme]
----
(questions
  ((id . "Q-001")
   (priority . "high")
   (question . "Which database engine?")
   (context . "Need to decide before Phase 2")
   (options . ("PostgreSQL" "SQLite" "DuckDB"))))
----

==== Question Entry Fields

[cols="2,1,1,4"]
|===
|Field |Type |Required |Description

|`id`
|String
|REQUIRED
|Unique question identifier

|`priority`
|Enum
|REQUIRED
|Urgency level

|`question`
|String
|REQUIRED
|The question text

|`context`
|String
|RECOMMENDED
|Background information

|`options`
|String[]
|OPTIONAL
|Available choices
|===

=== roadmap (OPTIONAL)

Long-term project planning.

[source,scheme]
----
(roadmap
  ((phase . "3.0 - Automation")
   (status . "next")
   (goals . ("Auto-export" "Diff tracking"))))
----

==== Roadmap Entry Fields

[cols="2,1,1,4"]
|===
|Field |Type |Required |Description

|`phase`
|String
|REQUIRED
|Phase name/identifier

|`status`
|Enum
|REQUIRED
|Phase status

|`goals`
|String[]
|REQUIRED
|Phase objectives
|===

==== Phase Status Enumeration

[cols="1,3"]
|===
|Value |Description

|`complete`
|Phase finished

|`current`
|Currently active phase

|`next`
|Immediate next phase

|`future`
|Planned but not imminent

|`vision`
|Long-term aspirational
|===

=== history (OPTIONAL)

Historical snapshots for velocity tracking.

[source,scheme]
----
(history
  (snapshots
    ((timestamp . "2025-12-06T10:00:00Z")
     (projects
       ((name . "My Project") (completion . 45))
       ((name . "Other Project") (completion . 80))))
    ((timestamp . "2025-12-08T12:00:00Z")
     (projects
       ((name . "My Project") (completion . 65))
       ((name . "Other Project") (completion . 95))))))
----

Snapshots SHOULD be ordered chronologically (oldest first).

=== files-created-this-session (OPTIONAL)

List of files created during the current session.

[source,scheme]
----
(files-created-this-session
  ("src/new-module.scm"
   "tests/new-test.scm"))
----

=== files-modified-this-session (OPTIONAL)

List of files modified during the current session.

[source,scheme]
----
(files-modified-this-session
  ("STATE.scm"
   "src/core.scm"))
----

=== context-notes (OPTIONAL)

Free-form textual summary of current context.

[source,scheme]
----
(context-notes . "Phase 2 complete. Focus shifting to automation.")
----

== Data Types

=== Primitive Types

[cols="1,2,3"]
|===
|Type |Format |Example

|String
|Double-quoted
|`"Hello, World!"`

|Integer
|Unquoted decimal
|`42`, `-7`

|Boolean
|Scheme symbols
|`#t` (true), `#f` (false)

|DateTime
|ISO 8601 in quotes
|`"2025-12-08T12:00:00Z"`

|Date
|ISO 8601 date only
|`"2025-12-08"`

|SemVer
|Major.Minor[.Patch]
|`"2.0"`, `"2.0.1"`
|===

=== Compound Types

[cols="1,3,3"]
|===
|Type |Syntax |Example

|List
|Parenthesized, space-separated
|`("a" "b" "c")`

|Pair
|Dotted notation
|`(key . value)`

|Object
|Nested pairs
|`((k1 . v1) (k2 . v2))`
|===

=== Null Values

The Scheme symbol `#f` represents null/missing values:

[source,scheme]
----
(deadline . #f)        ; No deadline set
(chat-reference . #f)  ; No reference
----

== Parsing Requirements

=== Conformance Levels

**Level 1 (Minimal)**::
  Parser can read and write STATE files with required sections only.

**Level 2 (Standard)**::
  Parser supports all sections including optional ones.

**Level 3 (Extended)**::
  Parser supports relational queries and graph generation.

=== Error Handling

Parsers MUST:

* Report clear errors for syntax violations
* Provide line/column numbers in error messages
* Reject files with unknown required fields
* Preserve unknown optional fields on round-trip

Parsers SHOULD:

* Provide warnings for deprecated fields
* Suggest corrections for common mistakes

== Serialization Bindings

=== JSON Binding

STATE files MAY be serialized to JSON for web interoperability:

[source,json]
----
{
  "metadata": {
    "formatVersion": "2.0",
    "schemaVersion": "2025-12-08",
    "createdAt": "2025-12-01T10:00:00Z",
    "lastUpdated": "2025-12-08T12:00:00Z"
  },
  "projects": [
    {
      "name": "My Project",
      "status": "in-progress",
      "completion": 65
    }
  ]
}
----

Field name mapping: kebab-case to camelCase.

=== YAML Binding

[source,yaml]
----
metadata:
  format-version: "2.0"
  schema-version: "2025-12-08"
  created-at: "2025-12-01T10:00:00Z"

projects:
  - name: "My Project"
    status: in-progress
    completion: 65
----

YAML binding preserves kebab-case field names.

== Security Considerations

=== Code Execution

STATE files are Scheme source code. Implementations MUST NOT execute
STATE files as code in untrusted contexts. The recommended approach:

1. Parse as data using a safe S-expression reader
2. Validate structure against schema
3. Extract values without evaluation

=== Sensitive Data

STATE files SHOULD NOT contain:

* Credentials or API keys
* Personal identifiable information (PII) beyond user name
* Proprietary business data

If sensitive data must be included, the file SHOULD be encrypted at rest.

=== Path Traversal

File paths in `files-created-this-session` and `files-modified-this-session`
MUST be validated to prevent path traversal attacks when used by
automation tools.

== IANA Considerations

=== Media Type Registration

This specification requests registration of the following media type:

[source]
----
Type name: application
Subtype name: x-state+scheme
Required parameters: None
Optional parameters: charset (default: utf-8)
Encoding considerations: 8bit
Security considerations: See Section 8
Interoperability considerations: See Section 7
Published specification: This document
Applications that use this media type: AI assistants, project management
Fragment identifier considerations: None
Additional information:
  File extension(s): .scm, .state
  Macintosh file type code(s): TEXT
Person & email address to contact: [TBD]
Intended usage: COMMON
Restrictions on usage: None
Author: Jonathan D.A. Jewell
Change controller: [TBD]
----

=== File Extension

The recommended file extension is `.scm` (standard Scheme) or `.state`
(STATE-specific).

== References

=== Normative References

[bibliography]
* [[[RFC2119]]] Bradner, S., "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, RFC 2119, March 1997.
* [[[RFC5234]]] Crocker, D. and P. Overell, "Augmented BNF for Syntax Specifications: ABNF", RFC 5234, January 2008.
* [[[RFC8259]]] Bray, T., "The JavaScript Object Notation (JSON) Data Interchange Format", RFC 8259, December 2017.
* [[[R7RS]]] Shinn, A., Cowan, J., and A. Gleckler, "Revised^7 Report on the Algorithmic Language Scheme", 2013.

=== Informative References

[bibliography]
* [[[RFC5545]]] Desruisseaux, B., "Internet Calendaring and Scheduling Core Object Specification (iCalendar)", RFC 5545, September 2009.
* [[[RFC7946]]] Butler, H., Daly, M., Doyle, A., Gillies, S., Hagen, S., and T. Schaub, "The GeoJSON Format", RFC 7946, August 2016.
* [[[SemVer]]] Preston-Werner, T., "Semantic Versioning 2.0.0", https://semver.org/

== Appendix A: Complete Example

[source,scheme]
----
;;; STATE.scm â€” AI Conversation Checkpoint File
;;; SPDX-License-Identifier: MIT AND LicenseRef-Palimpsest-0.8

(define state
  '((metadata
      (format-version . "2.0")
      (schema-version . "2025-12-08")
      (created-at . "2025-12-01T10:00:00Z")
      (last-updated . "2025-12-08T12:00:00Z")
      (generator . "Claude/STATE-system"))

    (user
      (name . "Alice Developer")
      (roles . ("Engineer" "Lead"))
      (preferences
        (languages-preferred . ("Rust" "TypeScript"))
        (languages-avoid . ("Java"))
        (tools-preferred . ("Nix" "VSCode"))
        (values . ("simplicity" "correctness"))))

    (session
      (conversation-id . "2025-12-08-planning")
      (started-at . "2025-12-08T09:00:00Z")
      (messages-used . 15)
      (messages-remaining . 85)
      (token-limit-reached . #f))

    (focus
      (current-project . "API Gateway")
      (current-phase . "Implementation")
      (deadline . "2025-12-31T23:59:59Z")
      (blocking-projects . ()))

    (projects
      ((name . "API Gateway")
       (status . "in-progress")
       (completion . 40)
       (category . "backend")
       (phase . "implementation")
       (dependencies . ("Auth Service"))
       (blockers . ())
       (next . ("Implement rate limiting" "Add logging"))
       (chat-reference . "2025-12-08-planning")
       (notes . "Core routing complete"))

      ((name . "Auth Service")
       (status . "complete")
       (completion . 100)
       (category . "backend")
       (phase . "complete")
       (dependencies . ())
       (blockers . ())
       (next . ())
       (chat-reference . #f)
       (notes . "Deployed to production")))

    (critical-next
      ("Implement rate limiting for API Gateway"
       "Write integration tests"
       "Update documentation"))

    (context-notes . "Auth complete, focusing on API Gateway features.")))
----

== Appendix B: ABNF Grammar

See the separate file `abnf/state.abnf` for the complete formal grammar.

== Appendix C: Changelog

=== Version 1.0.0-draft.1 (2025-12-15)

* Initial draft specification
* Complete section definitions
* ABNF grammar
* IANA media type request

== Authors' Addresses

Jonathan D.A. Jewell +
Email: [TBD] +
URI: https://github.com/hyperpolymath/state.scm
