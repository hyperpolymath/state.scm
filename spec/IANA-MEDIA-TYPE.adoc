= IANA Media Type Registration: application/state+scheme
:toc: left
:sectnums:

== Overview

This document contains the media type registration template for the STATE
format, intended for submission to IANA (Internet Assigned Numbers Authority).

== Registration Template

=== Type Name

`application`

=== Subtype Name

`state+scheme`

=== Required Parameters

None.

=== Optional Parameters

`charset`::
  The character set used in the STATE file. The default and RECOMMENDED
  value is `utf-8`. STATE files MUST be valid UTF-8 encoded text.

`version`::
  The format version of the STATE file (e.g., `2.0`). This parameter is
  OPTIONAL and is intended for content negotiation. If not specified,
  parsers SHOULD read the `format-version` field from the file metadata.

=== Encoding Considerations

8bit. STATE files are UTF-8 encoded text files containing Scheme/Lisp
S-expressions. No binary data is present in conforming files.

=== Security Considerations

STATE files are Scheme source code and MUST NOT be executed as code in
untrusted contexts. Implementations MUST:

1. Parse STATE files using a safe S-expression reader that does not
   evaluate code
2. Validate structure against the format schema before processing
3. Reject files containing executable forms beyond the `define state`
   structure

**Code Injection**: Malicious STATE files could potentially contain
Scheme code designed for execution. Parsers MUST use data-only readers
that do not evaluate expressions.

**Sensitive Data**: STATE files may contain project names, user
preferences, and contextual information. Users should be aware that
sharing STATE files exposes this metadata. Files SHOULD NOT contain
credentials, API keys, or other secrets.

**Path Traversal**: The `files-created-this-session` and
`files-modified-this-session` fields contain file paths. Automation
tools using these fields MUST validate paths to prevent directory
traversal attacks.

**Denial of Service**: Deeply nested S-expressions or extremely large
files could cause resource exhaustion. Parsers SHOULD implement
reasonable limits on:

* Maximum file size (RECOMMENDED: 10MB)
* Maximum nesting depth (RECOMMENDED: 100 levels)
* Maximum list length (RECOMMENDED: 10,000 items)

=== Interoperability Considerations

STATE files use S-expression syntax as defined by the Scheme programming
language (R7RS). The format is designed to be parseable by:

1. Native Scheme/Lisp implementations
2. Purpose-built S-expression parsers in any language
3. Conversion tools that transform to JSON, YAML, or EDN

**Serialization Bindings**: JSON and YAML serialization bindings are
defined in the specification. Field name mapping:

* Scheme: `kebab-case` (e.g., `format-version`)
* JSON: `camelCase` (e.g., `formatVersion`)
* YAML: `kebab-case` preserved

**Line Endings**: STATE files SHOULD use Unix line endings (LF). Parsers
MUST accept both Unix (LF) and Windows (CRLF) line endings.

**Comments**: Scheme-style comments (`;` and `#| |#`) are permitted and
MUST be preserved where possible during round-trip serialization.

=== Published Specification

The STATE Format Specification is available at:

* Repository: https://github.com/hyperpolymath/state.scm
* Specification: `spec/STATE-FORMAT-SPEC.adoc`
* ABNF Grammar: `spec/abnf/state.abnf`
* JSON Schema: `spec/schema/state.schema.json`

=== Applications That Use This Media Type

* **AI Assistants**: Claude, ChatGPT, and other LLM-based assistants for
  conversation context persistence
* **Project Management Tools**: Integration with task tracking systems
* **Development Environments**: IDE plugins for project state
  visualization
* **Automation Systems**: CI/CD pipelines and workflow automation

=== Fragment Identifier Considerations

No fragment identifier syntax is defined for this media type.

Future versions MAY define fragment identifiers for referencing specific
sections (e.g., `#/projects/MyProject`) using JSON Pointer-like syntax.

=== Additional Information

==== Deprecated Alias Names

None.

==== Magic Number(s)

STATE files begin with either:

* `(define state` - The canonical opening
* `;;;` - Comment header (typical in generated files)

The magic number `(define state` (14 bytes) uniquely identifies STATE
files.

==== File Extension(s)

`.scm`::
  Standard Scheme file extension (shared with other Scheme code)

`.state`::
  STATE-specific extension (RECOMMENDED for disambiguation)

==== Macintosh File Type Code(s)

`TEXT`

==== Object Identifier(s) or OID(s)

None defined.

=== Person & Email Address to Contact for Further Information

----
Jonathan D.A. Jewell
Email: [TBD]
GitHub: https://github.com/hyperpolymath
----

=== Intended Usage

COMMON

=== Restrictions on Usage

None.

=== Author

Jonathan D.A. Jewell

=== Change Controller

STATE Format Working Group (to be established)

Interim: Jonathan D.A. Jewell

== Provisional vs. Permanent Registration

=== Provisional Registration

For immediate use before RFC publication, a provisional registration using
the `x-` prefix is available:

----
Type: application
Subtype: x-state+scheme
----

Provisional registrations do not require IETF review but are subject to
removal if not subsequently registered permanently.

=== Permanent Registration Path

Permanent registration requires one of:

1. **Standards Track RFC**: Full IETF review process
2. **Informational/Experimental RFC**: IESG review
3. **Expert Review**: For widely deployed formats (RFC 6838)

The RECOMMENDED path is Informational RFC via Independent Submission
or Working Group adoption.

== Alternative Media Types Considered

[cols="2,3,2"]
|===
|Media Type |Reason Considered |Decision

|`application/x-scheme`
|Generic Scheme
|Too broad; STATE is specific format

|`application/vnd.state+scheme`
|Vendor tree
|Premature; may pursue standards tree

|`text/x-state`
|Text type
|Wrong type; structured data format

|`application/state`
|No suffix
|`+scheme` suffix aids content negotiation

|`application/state+lisp`
|Lisp family
|Scheme more specific
|===

== Content Negotiation

Servers serving STATE files SHOULD:

1. Return `Content-Type: application/state+scheme; charset=utf-8`
2. Support `Accept` header for format negotiation
3. Provide JSON binding when `Accept: application/json` is requested

Example:

[source]
----
GET /api/state HTTP/1.1
Accept: application/state+scheme

HTTP/1.1 200 OK
Content-Type: application/state+scheme; charset=utf-8; version=2.0

(define state ...)
----

[source]
----
GET /api/state HTTP/1.1
Accept: application/json

HTTP/1.1 200 OK
Content-Type: application/json

{"metadata": {...}, "projects": [...]}
----

== References

* RFC 6838 - Media Type Specifications and Registration Procedures
* RFC 4288 - Media Type Specifications (obsoleted by 6838)
* RFC 6839 - Additional Media Type Structured Syntax Suffixes
* IANA Media Types Registry: https://www.iana.org/assignments/media-types/
* R7RS - Revised^7 Report on Scheme

== Submission Checklist

* [ ] Complete registration template
* [ ] Security considerations documented
* [ ] Interoperability considerations documented
* [ ] Published specification available
* [ ] Reference implementation available
* [ ] Contact information current
* [ ] Submit to iana@iana.org (provisional) or via RFC (permanent)
